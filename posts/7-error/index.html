<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to deal with error in Go | works.collection</title>
<meta name="keywords" content="Golang">
<meta name="description" content="Prelude Any program may fall into wrong logic paths. And Go provides two mechanisms: error and panic. Errors could be used to inspect a execution result of a function, while panic generally represents a severe problem that may crash the whole program.
This article focus on error handling, which is a tricky yet critical part of go programming.
A little background Inheritance from C: return a number to denote execution result Benefits from multiple return values in Go Fundamental concepts // definition of error interface type error interface { Error() string } // New returns an error that formats as the given text.">
<meta name="author" content="">
<link rel="canonical" href="https://tacticalmixtu.github.io/posts/7-error/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tacticalmixtu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tacticalmixtu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tacticalmixtu.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tacticalmixtu.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tacticalmixtu.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://tacticalmixtu.github.io/posts/7-error/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="How to deal with error in Go" />
<meta property="og:description" content="Prelude Any program may fall into wrong logic paths. And Go provides two mechanisms: error and panic. Errors could be used to inspect a execution result of a function, while panic generally represents a severe problem that may crash the whole program.
This article focus on error handling, which is a tricky yet critical part of go programming.
A little background Inheritance from C: return a number to denote execution result Benefits from multiple return values in Go Fundamental concepts // definition of error interface type error interface { Error() string } // New returns an error that formats as the given text." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tacticalmixtu.github.io/posts/7-error/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-09T19:46:39+08:00" />
<meta property="article:modified_time" content="2020-11-09T19:46:39+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to deal with error in Go"/>
<meta name="twitter:description" content="Prelude Any program may fall into wrong logic paths. And Go provides two mechanisms: error and panic. Errors could be used to inspect a execution result of a function, while panic generally represents a severe problem that may crash the whole program.
This article focus on error handling, which is a tricky yet critical part of go programming.
A little background Inheritance from C: return a number to denote execution result Benefits from multiple return values in Go Fundamental concepts // definition of error interface type error interface { Error() string } // New returns an error that formats as the given text."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tacticalmixtu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to deal with error in Go",
      "item": "https://tacticalmixtu.github.io/posts/7-error/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to deal with error in Go",
  "name": "How to deal with error in Go",
  "description": "Prelude Any program may fall into wrong logic paths. And Go provides two mechanisms: error and panic. Errors could be used to inspect a execution result of a function, while panic generally represents a severe problem that may crash the whole program.\nThis article focus on error handling, which is a tricky yet critical part of go programming.\nA little background Inheritance from C: return a number to denote execution result Benefits from multiple return values in Go Fundamental concepts // definition of error interface type error interface { Error() string } // New returns an error that formats as the given text.",
  "keywords": [
    "Golang"
  ],
  "articleBody": "Prelude Any program may fall into wrong logic paths. And Go provides two mechanisms: error and panic. Errors could be used to inspect a execution result of a function, while panic generally represents a severe problem that may crash the whole program.\nThis article focus on error handling, which is a tricky yet critical part of go programming.\nA little background Inheritance from C: return a number to denote execution result Benefits from multiple return values in Go Fundamental concepts // definition of error interface type error interface { Error() string } // New returns an error that formats as the given text. func New(text string) error { return \u0026errorString{text} } Errors are values of error interface error is an interface type customized error type could be defined as long as it has a Error() method some error type is a struct which contains multiple fields, define Error() on the pointer to save space error values could be compared or type asserted comparing error values is not recommended cannot compare a error value with a “predefined” error value due to caveat: compare two error values comparing error messages is not recommended message strings should be read by humans, not program to compare error message, developers have to inspect exact error message, violate encapsulation error value could be stored and checked later instead of checking immediately although, in general we should handle error at the very time we encounter it, rather than ignoring it Errors should be handled gracefully do not return error values plainly since it may incur loop dependency problem violates encapsulation Error handling patterns Use the error values to check the execution succeeds or not if err := f(); err !=nil{ // err !=nil logic } // err == nil logic err == nil, a successful execution return nil explicitly: return nil caveat of returning a declared error value only deal with normal execution after checking errors never assume execution state if error occurs err != nil, inspect it Inspect a error value error values that should not be treated as a failed execution certain error values denote a successful execution, such as io.EOF certain error should not be returned to callers, such as timeout error in a request, a retry could be applied in this case error values that should be treated as a failed execution Implementation before Go 1.13: type assertion and type switch:\nif e, ok := err.(*QueryError); ok \u0026\u0026 e.Err == ErrPermission { // query failed because of a permission problem } Implementation after Go 1.13 errors.As() to perform type assertion errors.Is() to perform value comparison both of them consider all the errors in a chain in case of wrapped error values both of them could be “customized” or “overrode” in self-defined error type var e *QueryError // Note: *QueryError is the type of the error. if errors.As(err, \u0026e) { // err is a *QueryError, and e is set to the error's value } if errors.Is(err, ErrPermission) { // err, or some error that it wraps, is a permission problem } // Example of a customized Is() method type Error struct { Path string User string } func (e *Error) Is(target error) bool { t, ok := target.(*Error) if !ok { return false } return (e.Path == t.Path || t.Path == \"\") \u0026\u0026 (e.User == t.User || t.User == \"\") } if errors.Is(err, \u0026Error{User: \"someuser\"}) { // err's User field is \"someuser\". } Handle error values gracefully consider whether to return error do not wrap an error when doing so would expose implementation details wrapping an error makes that error part of your API how can the returned error values convey desired information in a concise way return errors with context avoid repetitive error checking logic Return error values with metadata define customized error types include some helpful information to debug wrap the error message with function/package name, argument, etc // PathError records an error and the operation and // file path that caused it. type PathError struct { Op string // \"open\", \"unlink\", etc. Path string // The associated file. Err error // Returned by the system call. } func (e *PathError) Error() string { return e.Op + \" \" + e.Path + \": \" + e.Err.Error() // may return error such as // open /etc/passwx: no such file or directory // but not some vague error such as // no such file or directory } // compose errors, pretty like the struct compose type QueryError struct { Query string Err error } Implementation before Go 1.13 compose manually with string concatenation fmt.Errorf() composes a formatted error values // string concatenation func (e *QueryError) Error() string { return e.Query + \": \" + e.Err.Error() } // fmt.Errorf() func (e *QueryError) Error() string { return fmt.Errorf(\"%v: %v\",e.Query, e.Err.Error()) } Implementation after Go 1.13: wrap the error implement Unwrap() method on customized error type use verb %w in fmt.Errorf() // Unwrap() func (e *QueryError) Unwrap() error { return e.Err } // %w verb if err != nil { // Return an error which unwraps to err. return fmt.Errorf(\"decompress %v: %w\", name, err) } Refactor function to avoid repetitive error checking logic Rewrite/wrap the whole function to provide a cleaner invocation way:\ntype appError struct { Error error Message string Code int } func init(){ http.Handle(\"/view\", appHandler(viewRecord)) } // wrapping type type appHandler func(http.ResponseWriter, *http.Request) *appError // it handles the error returned from encapsulated function // and it satisfies the ServeHTTP() function required by http/Handler interface func (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { if e := fn(w, r); e != nil { // e is *appError, not os.Error. c := appengine.NewContext(r) c.Errorf(\"%v\", e.Error) http.Error(w, e.Message, e.Code) } } // encapsulated function to do actual work and error check func viewRecord(w http.ResponseWriter, r *http.Request) *appError { c := appengine.NewContext(r) key := datastore.NewKey(c, \"Record\", r.FormValue(\"id\"), 0, nil) record := new(Record) if err := datastore.Get(c, key, record); err != nil { return \u0026appError{err, \"Record not found\", 404} } if err := viewTemplate.Execute(w, record); err != nil { return \u0026appError{err, \"Can't display record\", 500} } return nil } // Another example to refactor a function for better invocation logic type errWriter struct { w io.Writer err error } func (ew *errWriter) write(buf []byte) { // no need to check error for each invocation if ew.err != nil { return } _, ew.err = ew.w.Write(buf) } func main(){ ew := \u0026errWriter{w: fd} ew.write(p0[a:b]) ew.write(p1[c:d]) ew.write(p2[e:f]) if ew.err != nil { return ew.err } } Return a sentinel error value wrapped by a new exported customized error:\nvar ErrNotFound = errors.New(\"not found\") // FetchItem returns the named item. // If no item with the name exists, FetchItem returns an error // wrapping ErrNotFound. func FetchItem(name string) (*Item, error) { if itemNotFound(name) { return nil, fmt.Errorf(\"%q: %w\", name, ErrNotFound) } // ... } Caveats compare error value with nil error is an interface, therefore an error value includes type T value V only when both T and V are nil, the value is equal to nil func returnsError() error { var p *MyError = nil // p(T=*MyError, V=nil) if bad() { p = ErrBad } return p // p(T=*MyError, V=nil), therefore p!=nil } func returnsError() error { if bad() { return ErrBad } return nil } compare two error values Error values with same error message could be different, since each call to errors.New() creates a new errorString\nerr1 := errors.New(\"Error!\") err2 := errors.New(\"Error!\") if err1 != err2 { fmt.Println(\"err1 and err2 are two distinct error object\") } References from Effective Go Errors from official golang blog Error handing and Go Errors are values Working with Errors in Go 1.13 from official FAQ Why is my nil error value not equal to nil? from package documentation errors from blog posts of Dave Cheney Don’t just check errors, handle them gracefully ",
  "wordCount" : "1298",
  "inLanguage": "en",
  "datePublished": "2020-11-09T19:46:39+08:00",
  "dateModified": "2020-11-09T19:46:39+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tacticalmixtu.github.io/posts/7-error/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "works.collection",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tacticalmixtu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tacticalmixtu.github.io/" accesskey="h" title="works.collection (Alt + H)">works.collection</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      How to deal with error in Go
    </h1>
    <div class="post-meta"><span title='2020-11-09 19:46:39 +0800 CST'>November 9, 2020</span>

</div>
  </header> 
  <div class="post-content"><h2 id="prelude">Prelude<a hidden class="anchor" aria-hidden="true" href="#prelude">#</a></h2>
<p>Any program may fall into wrong logic paths. And Go provides two mechanisms: error and panic. Errors could be used to inspect a execution result of a function, while panic generally represents a severe problem that may crash the whole program.</p>
<p>This article focus on error handling, which is a tricky yet critical part of go programming.</p>
<h2 id="a-little-background">A little background<a hidden class="anchor" aria-hidden="true" href="#a-little-background">#</a></h2>
<ul>
<li>Inheritance from C: return a number to denote execution result</li>
<li>Benefits from multiple return values in Go</li>
</ul>
<h2 id="fundamental-concepts">Fundamental concepts<a hidden class="anchor" aria-hidden="true" href="#fundamental-concepts">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// definition of error interface
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">error</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// New returns an error that formats as the given text.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">text</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">errorString</span>{<span style="color:#a6e22e">text</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="errors-are-values-of-error-interface">Errors are values of error interface<a hidden class="anchor" aria-hidden="true" href="#errors-are-values-of-error-interface">#</a></h3>
<ul>
<li><code>error</code> is an interface type
<ul>
<li>customized error type could be defined as long as it has a <code>Error()</code> method
<ul>
<li>some error type is a struct which contains multiple fields, define Error() on the pointer to save space</li>
</ul>
</li>
</ul>
</li>
<li>error values could be compared or type asserted
<ul>
<li>comparing error values is <em>not recommended</em>
<ul>
<li>cannot compare a error value with a &ldquo;predefined&rdquo; error value due to <a href="#compare-two-error-values">caveat: compare two error values</a></li>
</ul>
</li>
<li>comparing error messages is <em>not recommended</em>
<ul>
<li>message strings should be read by humans, not program</li>
<li>to compare error message, developers have to inspect exact error message, violate encapsulation</li>
</ul>
</li>
</ul>
</li>
<li>error value could be <em>stored</em> and <em>checked later</em> instead of checking immediately
<ul>
<li>although, in general we should handle error at the very time we encounter it, rather than ignoring it</li>
</ul>
</li>
</ul>
<h3 id="errors-should-be-handled-gracefully">Errors should be handled <em>gracefully</em><a hidden class="anchor" aria-hidden="true" href="#errors-should-be-handled-gracefully">#</a></h3>
<ul>
<li>do not return error values plainly since it
<ul>
<li>may incur loop dependency problem</li>
<li>violates encapsulation</li>
</ul>
</li>
</ul>
<h2 id="error-handling-patterns">Error handling patterns<a hidden class="anchor" aria-hidden="true" href="#error-handling-patterns">#</a></h2>
<h3 id="use-the-error-values-to-check-the-execution-succeeds-or-not">Use the error values to check the execution succeeds or not<a hidden class="anchor" aria-hidden="true" href="#use-the-error-values-to-check-the-execution-succeeds-or-not">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span><span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// err !=nil logic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// err == nil logic
</span></span></span></code></pre></div><ul>
<li><code>err == nil</code>, a successful execution
<ul>
<li>return nil <em>explicitly</em>: <code>return nil</code>
<ul>
<li><a href="#nil-error-value">caveat of returning a declared error value</a></li>
</ul>
</li>
<li>only deal with normal execution <em>after</em> checking errors
<ul>
<li>never assume execution state if error occurs</li>
</ul>
</li>
</ul>
</li>
<li><code>err != nil</code>, <a href="#Inspect-a-error-value">inspect it</a></li>
</ul>
<h3 id="inspect-a-error-value">Inspect a error value<a hidden class="anchor" aria-hidden="true" href="#inspect-a-error-value">#</a></h3>
<ul>
<li>error values that should not be treated as a failed execution
<ul>
<li>certain error values denote a successful execution, such as <code>io.EOF</code></li>
<li>certain error should not be returned to callers, such as timeout error in a request, a retry could be applied in this case</li>
</ul>
</li>
<li>error values that should be treated as a failed execution</li>
</ul>
<p>Implementation before Go 1.13: type assertion and type switch:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">QueryError</span>); <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Err</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">ErrPermission</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// query failed because of a permission problem
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span></code></pre></div><ul>
<li>Implementation after Go 1.13
<ul>
<li><code>errors.As()</code> to perform type assertion</li>
<li><code>errors.Is()</code> to perform value comparison</li>
<li>both of them consider all the errors in a chain in case of wrapped error values</li>
<li>both of them could be &ldquo;customized&rdquo; or &ldquo;overrode&rdquo; in self-defined error type</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">QueryError</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Note: *QueryError is the type of the error.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">As</span>(<span style="color:#a6e22e">err</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// err is a *QueryError, and e is set to the error&#39;s value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Is</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">ErrPermission</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// err, or some error that it wraps, is a permission problem
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Example of a customized Is() method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Error</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Path</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">User</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Error</span>) <span style="color:#a6e22e">Is</span>(<span style="color:#a6e22e">target</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">target</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">Error</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Path</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Path</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Path</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>           (<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">User</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">User</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">User</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Is</span>(<span style="color:#a6e22e">err</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Error</span>{<span style="color:#a6e22e">User</span>: <span style="color:#e6db74">&#34;someuser&#34;</span>}) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// err&#39;s User field is &#34;someuser&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span></code></pre></div><h3 id="handle-error-values-gracefully">Handle error values gracefully<a hidden class="anchor" aria-hidden="true" href="#handle-error-values-gracefully">#</a></h3>
<ul>
<li>consider <em>whether</em> to return error
<ul>
<li>do not wrap an error when doing so would expose implementation details</li>
<li>wrapping an error makes that error part of your API</li>
</ul>
</li>
<li>how can the returned error values convey desired information in a <em>concise</em> way
<ul>
<li>return errors with context</li>
<li>avoid repetitive error checking logic</li>
</ul>
</li>
</ul>
<h3 id="return-error-values-with-metadata">Return error values with metadata<a hidden class="anchor" aria-hidden="true" href="#return-error-values-with-metadata">#</a></h3>
<ul>
<li>define customized error types
<ul>
<li>include some helpful information to debug</li>
</ul>
</li>
<li>wrap the error message with function/package name, argument, etc</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// PathError records an error and the operation and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// file path that caused it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PathError</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Op</span> <span style="color:#66d9ef">string</span>    <span style="color:#75715e">// &#34;open&#34;, &#34;unlink&#34;, etc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Path</span> <span style="color:#66d9ef">string</span>  <span style="color:#75715e">// The associated file.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Err</span> <span style="color:#66d9ef">error</span>    <span style="color:#75715e">// Returned by the system call.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">PathError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Op</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Path</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Err</span>.<span style="color:#a6e22e">Error</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// may return error such as
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// open /etc/passwx: no such file or directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// but not some vague error such as
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// no such file or directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// compose errors, pretty like the struct compose
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">QueryError</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Query</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Err</span>   <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Implementation before Go 1.13
<ul>
<li>compose manually with string concatenation</li>
<li><code>fmt.Errorf()</code> composes a formatted error values</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// string concatenation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">QueryError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Query</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Err</span>.<span style="color:#a6e22e">Error</span>() 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// fmt.Errorf()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">QueryError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;%v: %v&#34;</span>,<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Query</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Err</span>.<span style="color:#a6e22e">Error</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Implementation after Go 1.13: <strong>wrap</strong> the error
<ul>
<li>implement Unwrap() method on customized error type</li>
<li>use verb <code>%w</code> in <code>fmt.Errorf()</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Unwrap()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">QueryError</span>) <span style="color:#a6e22e">Unwrap</span>() <span style="color:#66d9ef">error</span> { 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Err</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// %w verb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Return an error which unwraps to err.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;decompress %v: %w&#34;</span>, <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h3 id="refactor-function-to-avoid-repetitive-error-checking-logic">Refactor function to avoid repetitive error checking logic<a hidden class="anchor" aria-hidden="true" href="#refactor-function-to-avoid-repetitive-error-checking-logic">#</a></h3>
<p>Rewrite/wrap the whole function to provide a cleaner invocation way:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">appError</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Error</span>   <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Code</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Handle</span>(<span style="color:#e6db74">&#34;/view&#34;</span>, <span style="color:#a6e22e">appHandler</span>(<span style="color:#a6e22e">viewRecord</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// wrapping type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">appHandler</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">appError</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// it handles the error returned from encapsulated function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// and it satisfies the ServeHTTP() function required by http/Handler interface
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">appHandler</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> { <span style="color:#75715e">// e is *appError, not os.Error.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">appengine</span>.<span style="color:#a6e22e">NewContext</span>(<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;%v&#34;</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Error</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Message</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Code</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// encapsulated function to do actual work and error check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewRecord</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">appError</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">appengine</span>.<span style="color:#a6e22e">NewContext</span>(<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">datastore</span>.<span style="color:#a6e22e">NewKey</span>(<span style="color:#a6e22e">c</span>, <span style="color:#e6db74">&#34;Record&#34;</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">FormValue</span>(<span style="color:#e6db74">&#34;id&#34;</span>), <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">record</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">Record</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">datastore</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">record</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">appError</span>{<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;Record not found&#34;</span>, <span style="color:#ae81ff">404</span>}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">viewTemplate</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">record</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">appError</span>{<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;Can&#39;t display record&#34;</span>, <span style="color:#ae81ff">500</span>}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Another example to refactor a function for better invocation logic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">errWriter</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span>   <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ew</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">errWriter</span>) <span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">buf</span> []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// no need to check error for each invocation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ew</span>.<span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ew</span>.<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">ew</span>.<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ew</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">errWriter</span>{<span style="color:#a6e22e">w</span>: <span style="color:#a6e22e">fd</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ew</span>.<span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">p0</span>[<span style="color:#a6e22e">a</span>:<span style="color:#a6e22e">b</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ew</span>.<span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">p1</span>[<span style="color:#a6e22e">c</span>:<span style="color:#a6e22e">d</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ew</span>.<span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">p2</span>[<span style="color:#a6e22e">e</span>:<span style="color:#a6e22e">f</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ew</span>.<span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ew</span>.<span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Return a sentinel error value wrapped by a new exported customized error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ErrNotFound</span> = <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;not found&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FetchItem returns the named item.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If no item with the name exists, FetchItem returns an error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// wrapping ErrNotFound.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">FetchItem</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">Item</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">itemNotFound</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;%q: %w&#34;</span>, <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">ErrNotFound</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="caveats">Caveats<a hidden class="anchor" aria-hidden="true" href="#caveats">#</a></h2>
<h3 id="compare-error-value-with-nil">compare error value with nil<a hidden class="anchor" aria-hidden="true" href="#compare-error-value-with-nil">#</a></h3>
<ul>
<li><code>error</code> is an interface, therefore an error value includes
<ul>
<li>type T</li>
<li>value V</li>
</ul>
</li>
<li>only when both T and V are nil, the value is equal to nil</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">returnsError</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MyError</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// p(T=*MyError, V=nil)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bad</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span> = <span style="color:#a6e22e">ErrBad</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span> <span style="color:#75715e">// p(T=*MyError, V=nil), therefore p!=nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">returnsError</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bad</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ErrBad</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="compare-two-error-values">compare two error values<a hidden class="anchor" aria-hidden="true" href="#compare-two-error-values">#</a></h3>
<p>Error values with same error message could be different, since each call to <code>errors.New()</code> creates a new <code>errorString</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#a6e22e">err1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;Error!&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">err2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;Error!&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err1</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">err2</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;err1 and err2 are two distinct error object&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ul>
<li>from Effective Go
<ul>
<li><a href="https://golang.org/doc/effective_go.html#errors">Errors</a></li>
</ul>
</li>
<li>from official golang blog
<ul>
<li><a href="https://blog.golang.org/error-handling-and-go">Error handing and Go</a></li>
<li><a href="https://blog.golang.org/errors-are-values">Errors are values</a></li>
<li><a href="https://blog.golang.org/go1.13-errors">Working with Errors in Go 1.13</a></li>
</ul>
</li>
<li>from official FAQ
<ul>
<li><a href="https://golang.org/doc/faq#nil_error">Why is my nil error value not equal to nil?</a></li>
</ul>
</li>
<li>from package documentation
<ul>
<li><a href="https://pkg.go.dev/errors">errors</a></li>
</ul>
</li>
<li>from blog posts of Dave Cheney
<ul>
<li><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a></li>
</ul>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tacticalmixtu.github.io/tags/golang/">Golang</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
