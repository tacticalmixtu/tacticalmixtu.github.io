<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Shortest Path Problems | works.collection</title>
<meta name="keywords" content="Algorithms">
<meta name="description" content="Single source Non-negative weighted graph &ndash; Dijkstra Algorithm Why does it work? greedy algorithm Naive Approach Time complexity: $O(V^2)$, since outer loop would access at most V-1 nodes and inner loop would access at most V-1 nodes Space complexity: $O(V^2)$, adjacent matrix Suitable for dense graph Use adjacent matrix to represent graph compared to queue-based approach, it avoids complexity incurred by large amount of edges Example: 743. Network Delay Time">
<meta name="author" content="">
<link rel="canonical" href="https://tacticalmixtu.github.io/posts/1-shortest/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tacticalmixtu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tacticalmixtu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tacticalmixtu.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tacticalmixtu.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tacticalmixtu.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://tacticalmixtu.github.io/posts/1-shortest/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Shortest Path Problems" />
<meta property="og:description" content="Single source Non-negative weighted graph &ndash; Dijkstra Algorithm Why does it work? greedy algorithm Naive Approach Time complexity: $O(V^2)$, since outer loop would access at most V-1 nodes and inner loop would access at most V-1 nodes Space complexity: $O(V^2)$, adjacent matrix Suitable for dense graph Use adjacent matrix to represent graph compared to queue-based approach, it avoids complexity incurred by large amount of edges Example: 743. Network Delay Time" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tacticalmixtu.github.io/posts/1-shortest/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-26T17:59:33-04:00" />
<meta property="article:modified_time" content="2020-08-26T17:59:33-04:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Shortest Path Problems"/>
<meta name="twitter:description" content="Single source Non-negative weighted graph &ndash; Dijkstra Algorithm Why does it work? greedy algorithm Naive Approach Time complexity: $O(V^2)$, since outer loop would access at most V-1 nodes and inner loop would access at most V-1 nodes Space complexity: $O(V^2)$, adjacent matrix Suitable for dense graph Use adjacent matrix to represent graph compared to queue-based approach, it avoids complexity incurred by large amount of edges Example: 743. Network Delay Time"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tacticalmixtu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Shortest Path Problems",
      "item": "https://tacticalmixtu.github.io/posts/1-shortest/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Shortest Path Problems",
  "name": "Shortest Path Problems",
  "description": "Single source Non-negative weighted graph \u0026ndash; Dijkstra Algorithm Why does it work? greedy algorithm Naive Approach Time complexity: $O(V^2)$, since outer loop would access at most V-1 nodes and inner loop would access at most V-1 nodes Space complexity: $O(V^2)$, adjacent matrix Suitable for dense graph Use adjacent matrix to represent graph compared to queue-based approach, it avoids complexity incurred by large amount of edges Example: 743. Network Delay Time",
  "keywords": [
    "Algorithms"
  ],
  "articleBody": "Single source Non-negative weighted graph – Dijkstra Algorithm Why does it work? greedy algorithm Naive Approach Time complexity: $O(V^2)$, since outer loop would access at most V-1 nodes and inner loop would access at most V-1 nodes Space complexity: $O(V^2)$, adjacent matrix Suitable for dense graph Use adjacent matrix to represent graph compared to queue-based approach, it avoids complexity incurred by large amount of edges Example: 743. Network Delay Time\nfunc networkDelayTime(times [][]int, N int, K int) int { // N will be in the range [1, 100]. // K will be in the range [1, N]. // The length of times will be in the range [1, 6000]. // All edges times[i] = (u, v, w) will have 1 \u003c= u, v \u003c= N and 0 \u003c= w \u003c= 100. // create adjacent matrix graph := make([][]int, N) for i := range graph { graph[i] = make([]int, N) for j := range graph[i] { // -1 means unreachable // graph[i][j] = -1 graph[i][j] = math.MaxInt32 } } for i := range times { from, to, weight := times[i][0]-1, times[i][1]-1, times[i][2] graph[from][to] = weight } // distance[i]: distance of (K,i) // given K is k-th, but we use it as index to denote node K-- distance := make([]int, N) for i := range graph[K] { distance[i] = graph[K][i] } distance[K] = 0 visited := make([]bool, N) visited[K] = true // iterate at most N-1 loops for all nodes expect K for i := 0; i \u003c N-1; i++ { localMin := math.MaxInt32 // find the selected node in Q (un-explored) region with smallest distance (K,selected) var selected int for j := 0; j \u003c N; j++ { if !visited[j] \u0026\u0026 distance[j] \u003c localMin { localMin = distance[j] selected = j } } // now selected node is added into P(explored) region visited[selected] = true // now could relax all out edges of selected node for j := range graph[selected] { // must skip unreachable edges, otherwise could cause overflow in next addition operation: distance[selected]+graph[selected][j] if graph[selected][j] == math.MaxInt32 { continue } // for (K,j), take a detour if (K,j) \u003e (K,selected) + (selected,j) if distance[selected]+graph[selected][j] \u003c distance[j] { distance[j] = distance[selected] + graph[selected][j] } } } var max int for _, dis := range distance { if dis \u003e max { max = dis } } // unreachable nodes from K exists if max == math.MaxInt32 { return -1 } return max } Queue-based Approach Time complexity: $O(ElogV)$, based on implementation of heap Space complexity Suitable for sparse graph: use adjacent list to represent graph Example: 1368. Minimum Cost to Make at Least One Valid Path in a Grid\nfunc minCost(grid [][]int) int { // simulate a graph with weighted edge computed from sign of each cell // corresponding to 1,2,3,4 and left, right, down, up rowDir := [4]int{0, 0, 1, -1} colDir := [4]int{1, -1, 0, 0} // m == grid.length // n == grid[i].length // 1 \u003c= m, n \u003c= 100 m := len(grid) n := len(grid[0]) distance := make([]int, n*m) for i := range distance { distance[i] = math.MaxInt32 } distance[0] = 0 visited := make([]bool, n*m) // do not mark source as visited since we only mark it once we finish accessing all its adjacent cells // visited[0]= true h := \u0026minHeap{{0, 0}} heap.Init(h) for h.Len() \u003e 0 { p, ok := heap.Pop(h).(*node) if !ok { log.Fatal() } if visited[p.label] { continue } visited[p.label] = true currentRow := p.label / n currentCol := p.label % n for i := range rowDir { newRow := currentRow + rowDir[i] newCol := currentCol + colDir[i] if newRow \u003c 0 || newRow \u003e= m || newCol \u003c 0 || newCol \u003e= n { continue } newLabel := newRow*n + newCol newDistance := p.distanceTo // cost of chaning sign if grid[currentRow][currentCol] != i+1 { newDistance++ } // relax if newDistance \u003c distance[newLabel] { distance[newLabel] = newDistance heap.Push(h, \u0026node{newDistance, newLabel}) } } } // there must be a valid path return distance[len(distance)-1] } Negative weighted graph – Bellman-Ford Algorithm Time: $O(V^2)$\nExample: 787. Cheapest Flights Within K Stops\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int { // The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1. // The size of flights will be in range [0, n * (n - 1) / 2]. // There will not be any duplicated flights or self cycles. // n vertices and m edges distance := make([]int, n) for i := range distance { // The price of each flight will be in the range [1, 10000]. // maxint32 implies unreachable distance[i] = math.MaxInt32 } distance[src] = 0 // k is in the range of [0, n - 1]. // at most K stops, means at most K+2 vertices on path // therefore require K iterations for i := 0; i \u003c K+1; i++ { currentDistance := make([]int, len(distance)) copy(currentDistance, distance) // relax all edges for j := range flights { // The format of each flight will be (src, dst, price). from, to, weight := flights[j][0], flights[j][1], flights[j][2] if currentDistance[to] \u003e distance[from]+weight { currentDistance[to] = distance[from] + weight } } distance = currentDistance } // check negative cycles if distance[dst] == math.MaxInt32 { return -1 } return distance[dst] } All pairs – Floyd-Warshall Algorithm To solve shortest paths problems for all pairs of vertices\napply Dijkstra to each node, results in $O(V * E logV)$ floyd, $O(V^3)$ Why does it work? dynamic programming\nrelax edges with constrains on detoured vertex table space reduction, since k’s state relies only on k-1’s state Example: 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance\nfunc findTheCity(n int, edges [][]int, distanceThreshold int) int { // 2 \u003c= n \u003c= 100 // 1 \u003c= edges.length \u003c= n * (n - 1) / 2, could be dense graph table := make([][]int, n) for i := range table { table[i] = make([]int, n) for j := range table[i] { // initialize to unreachable table[i][j] = math.MaxInt32 } } for i := range edges { // All edges are distinct. // edges[i].length == 3 from, to, weight := edges[i][0], edges[i][1], edges[i][2] // directly connected table[from][to] = weight table[to][from] = weight } // k's range is [0,n], but 0 is handled in previous // k stays at most outer loop so that at k round, it could use k-1's table and reuse it for k := 0; k \u003c n; k++ { for i := range table { for j := range table[i] { // skip self, and unreachable case to avoid integer overflow if i == j || table[i][k] == math.MaxInt32 || table[k][j] == math.MaxInt32 { continue } // relax for each i,j edge, consider to take a detour or not // k's table[i][j] if table[i][j] \u003e table[i][k]+table[k][j] { table[i][j] = table[i][k] + table[k][j] } } } } // distanceThreshold \u003c= 10^4 minCount := math.MaxInt32 var res int for i := range table { count := 0 for j := range table[i] { if table[i][j] \u003c= distanceThreshold { count++ } } if count \u003c= minCount { minCount = count res = i } } return res } ",
  "wordCount" : "1195",
  "inLanguage": "en",
  "datePublished": "2020-08-26T17:59:33-04:00",
  "dateModified": "2020-08-26T17:59:33-04:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tacticalmixtu.github.io/posts/1-shortest/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "works.collection",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tacticalmixtu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tacticalmixtu.github.io/" accesskey="h" title="works.collection (Alt + H)">works.collection</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Shortest Path Problems
    </h1>
    <div class="post-meta"><span title='2020-08-26 17:59:33 -0400 -0400'>August 26, 2020</span>

</div>
  </header> 
  <div class="post-content"><h2 id="single-source">Single source<a hidden class="anchor" aria-hidden="true" href="#single-source">#</a></h2>
<h3 id="non-negative-weighted-graph----dijkstra-algorithm">Non-negative weighted graph &ndash; Dijkstra Algorithm<a hidden class="anchor" aria-hidden="true" href="#non-negative-weighted-graph----dijkstra-algorithm">#</a></h3>
<ul>
<li>Why does it work?
<ul>
<li>greedy algorithm</li>
</ul>
</li>
</ul>
<h4 id="naive-approach">Naive Approach<a hidden class="anchor" aria-hidden="true" href="#naive-approach">#</a></h4>
<ul>
<li>Time complexity: $O(V^2)$, since outer loop would access at most V-1 nodes and inner loop would access at most V-1 nodes</li>
<li>Space complexity: $O(V^2)$, adjacent matrix</li>
<li>Suitable for <em>dense graph</em>
<ul>
<li>Use adjacent matrix to represent graph</li>
<li>compared to queue-based approach, it avoids complexity incurred by large amount of edges</li>
</ul>
</li>
</ul>
<p>Example: <a href="https://leetcode.com/problems/network-delay-time/">743. Network Delay Time</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">networkDelayTime</span>(<span style="color:#a6e22e">times</span> [][]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">N</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">K</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// N will be in the range [1, 100].
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// K will be in the range [1, N].
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// The length of times will be in the range [1, 6000].
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// All edges times[i] = (u, v, w) will have 1 &lt;= u, v &lt;= N and 0 &lt;= w &lt;= 100.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// create adjacent matrix
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">graph</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">N</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">graph</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">i</span>] = make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">N</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// -1 means unreachable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// graph[i][j] = -1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">times</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">from</span>, <span style="color:#a6e22e">to</span>, <span style="color:#a6e22e">weight</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">times</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">times</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">times</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">from</span>][<span style="color:#a6e22e">to</span>] = <span style="color:#a6e22e">weight</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// distance[i]: distance of (K,i)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// given K is k-th, but we use it as index to denote node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">K</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">distance</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">N</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">K</span>] {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">K</span>][<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">K</span>] = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">visited</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">N</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">K</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// iterate at most N-1 loops for all nodes expect K
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">N</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">localMin</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// find the selected node in Q (un-explored) region with smallest distance (K,selected)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">selected</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">j</span>] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">j</span>] &lt; <span style="color:#a6e22e">localMin</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">localMin</span> = <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">j</span>]
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">selected</span> = <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// now selected node is added into P(explored) region
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">selected</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// now could relax all out edges of selected node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">selected</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// must skip unreachable edges, otherwise could cause overflow in next addition operation: distance[selected]+graph[selected][j]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">selected</span>][<span style="color:#a6e22e">j</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// for (K,j), take a detour if (K,j) &gt; (K,selected) + (selected,j)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">selected</span>]<span style="color:#f92672">+</span><span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">selected</span>][<span style="color:#a6e22e">j</span>] &lt; <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">j</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">selected</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">graph</span>[<span style="color:#a6e22e">selected</span>][<span style="color:#a6e22e">j</span>]
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">max</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">dis</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">distance</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">dis</span> &gt; <span style="color:#a6e22e">max</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">max</span> = <span style="color:#a6e22e">dis</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// unreachable nodes from K exists
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">max</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">max</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="queue-based-approach">Queue-based Approach<a hidden class="anchor" aria-hidden="true" href="#queue-based-approach">#</a></h4>
<ul>
<li>Time complexity: $O(ElogV)$, based on implementation of heap</li>
<li>Space complexity</li>
<li>Suitable for <em>sparse graph</em>:
<ul>
<li>use adjacent list to represent graph</li>
</ul>
</li>
</ul>
<p>Example: <a href="https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/">1368. Minimum Cost to Make at Least One Valid Path in a Grid</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">minCost</span>(<span style="color:#a6e22e">grid</span> [][]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// simulate a graph with weighted edge computed from sign of each cell
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// corresponding to 1,2,3,4 and left, right, down, up
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">rowDir</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">colDir</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// m == grid.length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// n == grid[i].length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1 &lt;= m, n &lt;= 100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">grid</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">grid</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">distance</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">distance</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">distance</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">visited</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do not mark source as visited since we only mark it once we finish accessing all its adjacent cells
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// visited[0]= true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">minHeap</span>{{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>}}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">heap</span>.<span style="color:#a6e22e">Init</span>(<span style="color:#a6e22e">h</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">Len</span>() &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">heap</span>.<span style="color:#a6e22e">Pop</span>(<span style="color:#a6e22e">h</span>).(<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">label</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">label</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">currentRow</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">label</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">currentCol</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">label</span> <span style="color:#f92672">%</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">rowDir</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">newRow</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">currentRow</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">rowDir</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">newCol</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">currentCol</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">colDir</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newRow</span> &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">newRow</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">newCol</span> &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">newCol</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">n</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">newLabel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newRow</span><span style="color:#f92672">*</span><span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">newCol</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">newDistance</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">distanceTo</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// cost of chaning sign
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">currentRow</span>][<span style="color:#a6e22e">currentCol</span>] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">newDistance</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// relax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newDistance</span> &lt; <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">newLabel</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">newLabel</span>] = <span style="color:#a6e22e">newDistance</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">heap</span>.<span style="color:#a6e22e">Push</span>(<span style="color:#a6e22e">h</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">newDistance</span>, <span style="color:#a6e22e">newLabel</span>})
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// there must be a valid path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">distance</span>[len(<span style="color:#a6e22e">distance</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="negative-weighted-graph----bellman-ford-algorithm">Negative weighted graph &ndash; Bellman-Ford Algorithm<a hidden class="anchor" aria-hidden="true" href="#negative-weighted-graph----bellman-ford-algorithm">#</a></h3>
<p>Time: $O(V^2)$</p>
<p>Example: <a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">787. Cheapest Flights Within K Stops</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">findCheapestPrice</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">flights</span> [][]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">src</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">dst</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">K</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// The size of flights will be in range [0, n * (n - 1) / 2].
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// There will not be any duplicated flights or self cycles.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// n vertices and m edges
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">distance</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">distance</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The price of each flight will be in the range [1, 10000].
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// maxint32 implies unreachable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">src</span>] = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// k is in the range of [0, n - 1].
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// at most K stops, means at most K+2 vertices on path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// therefore require K iterations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">K</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">currentDistance</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, len(<span style="color:#a6e22e">distance</span>))
</span></span><span style="display:flex;"><span>        copy(<span style="color:#a6e22e">currentDistance</span>, <span style="color:#a6e22e">distance</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// relax all edges
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">flights</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// The format of each flight will be (src, dst, price).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">from</span>, <span style="color:#a6e22e">to</span>, <span style="color:#a6e22e">weight</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">flights</span>[<span style="color:#a6e22e">j</span>][<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">flights</span>[<span style="color:#a6e22e">j</span>][<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">flights</span>[<span style="color:#a6e22e">j</span>][<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentDistance</span>[<span style="color:#a6e22e">to</span>] &gt; <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">from</span>]<span style="color:#f92672">+</span><span style="color:#a6e22e">weight</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">currentDistance</span>[<span style="color:#a6e22e">to</span>] = <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">from</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">weight</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">distance</span> = <span style="color:#a6e22e">currentDistance</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// check negative cycles
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">dst</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">distance</span>[<span style="color:#a6e22e">dst</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="all-pairs----floyd-warshall-algorithm">All pairs &ndash; Floyd-Warshall Algorithm<a hidden class="anchor" aria-hidden="true" href="#all-pairs----floyd-warshall-algorithm">#</a></h2>
<ul>
<li>
<p>To solve shortest paths problems for all pairs of vertices</p>
<ul>
<li>apply Dijkstra to each node, results in $O(V * E logV)$</li>
<li>floyd, $O(V^3)$</li>
</ul>
</li>
<li>
<p>Why does it work? dynamic programming</p>
<ul>
<li>relax edges with constrains on detoured vertex</li>
<li>table space reduction, since k&rsquo;s state relies only on k-1&rsquo;s state</li>
</ul>
</li>
</ul>
<p>Example: <a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">findTheCity</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">edges</span> [][]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">distanceThreshold</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2 &lt;= n &lt;= 100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1 &lt;= edges.length &lt;= n * (n - 1) / 2, could be dense graph
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">table</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">table</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>] = make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// initialize to unreachable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">edges</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// All edges are distinct.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// edges[i].length == 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">from</span>, <span style="color:#a6e22e">to</span>, <span style="color:#a6e22e">weight</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">edges</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">edges</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">edges</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// directly connected
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">from</span>][<span style="color:#a6e22e">to</span>] = <span style="color:#a6e22e">weight</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">to</span>][<span style="color:#a6e22e">from</span>] = <span style="color:#a6e22e">weight</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// k&#39;s range is [0,n], but 0 is handled in previous
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// k stays at most outer loop so that at k round, it could use k-1&#39;s table and reuse it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">table</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// skip self, and unreachable case to avoid integer overflow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">k</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">k</span>][<span style="color:#a6e22e">j</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// relax for each i,j edge, consider to take a detour or not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// k&#39;s table[i][j]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] &gt; <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">k</span>]<span style="color:#f92672">+</span><span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">k</span>][<span style="color:#a6e22e">j</span>] {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">k</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">k</span>][<span style="color:#a6e22e">j</span>]
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// distanceThreshold &lt;= 10^4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">minCount</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">table</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">distanceThreshold</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">count</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">minCount</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">minCount</span> = <span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tacticalmixtu.github.io/tags/algorithms/">Algorithms</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
